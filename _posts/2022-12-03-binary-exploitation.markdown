---
layout:   post
title:   Binary Exploitation
description:   desc
date:   2022-12-03 01:20:00 +0300
image: '/assets/img/posts/tryhackme-hackpark-ctf-writeup/parkbanner.jpg'
tags:   [c,shell-coding,binary-exploitation,buffer-overflows]
featured:   false
---

In this blog post I will cover binary exploitation techniques, memory structure mechanisms,
buffer overflows, shell coding and more. Before moving any further, in order to understand
how things work, you need to have a little programming background. No extensive amount
of knowledge required since I will go through everything. However, basic concepts will go
uncovered for sake of simplicity.

# Baby Steps

We will use C programming language through the post. Since the C programming language is the closest one
to the machine code after assembly, we will use it in order to analyze how variables, arrays, functions
are taking their place in memory and how the CPU work with those data.

So, let's get right to it. We will start really easy. It is a piece of code prints out a "Hello World" message
to the screen for five times.
![](/assets/img/posts/binary-exploitation/1.png)<br>

Let's compile and run it.
![](/assets/img/posts/binary-exploitation/2.png)<br>

The aim of that paper will gain a perspective on how hackers see the code and exploit them. In order for us to 
see the bigger picture, we have to analyze each step carefully. Therefore, I will start by making that statement:
the **firstprogram.c** is just a text file, and it does not carry and meaning for CPU except it is just being a simple text
file. It is what we call **the source code**. It should be complied (as we did) into an executable binary file, **.exe**
for windows and **ELF executable** for Linux in 2022. We can think of the compiler as a middle ground. 
There are different CPU architectures, the instruction set for ARM will not work with x86, SPARC, x64,etc.
For each architecture, specialized machine code should be written for 
the same piece of program. It is pain. Instead, people write their programs in the C syntax and the compiler translates 
that piece of source code into the machine code with the available instruction set that the present CPU supplies. 
When the executable has executed, its instructions are getting loaded to the **RAM** for the CPU (or GPU) to handle.<br>

Here things goes tricky. From the programmers' perspective they should only focus on coding a well functioning program.
However, hacker knows that the compiled machine code is what actually getting executed by the CPU in the real world.
By having a deep understanding on how the CPU works, hacker can manipulate the expected behavior in their behalf.<br>

We can see how that binary executable look like with a **GNU developement tool** called **objdump**. Let's see what
that the **main()** function had translated to.

![](/assets/img/posts/binary-exploitation/3.png)<br>

Each byte is represented in hexadecimal notation, which is a base-16 numbering system, since it is more practical
to express an 8-bit value by using two characters instead of eight. The hex numbers at the far left ending with a colon are 
the memory addresses. Those addresses are where the instructions are getting stored as a collection of bytes for 
a temporary amount of time for the CPU to handle.<br>

Memory can be thought as a row of bytes. Each row has a defined space (1 byte %99.9 of the time) and each defined 
space starts with an address. Therefore, when we say that we have a 64-bit processor we are saying that our CPU supports
2^64 (18 billion) possible addresses.<br>

The hex values at the middle are the machine language instructions for the processor. For example, let's examine the
first instruction. It is 0x55 (hexadecimal notation starts with a 0x as a rule of thumb) in hexadecimal, 
85 in decimal when converted, and 1010101 in binary. Since processors can only handle ones and zeroes, 
that hex value being red as its binary value in the CPU. And for the current instruction set that operation code, 
which is 0x55, means : **push %rbp** in assembly language. And the texts at the far right, just like I said,
they are assembly code human-readable representations of the machine instructions.<br>

# Assembly Languagae
Each CPU comes with different instruction set. Therefore, an assembly 
programmer can not follow the common sense as they do with a compiled language. They have to read the actual CPU manual
book, and follow its own instructions to write their own program accordingly since assembly is converted directly 
to the machine code with no compilation process. When it comes to syntax, there are two common assembly syntaxes:
Intel and AT&T. The picture above in default AT&T syntax.

## How Assembly Works?
The assembly instructions in Intel syntax generally follow this style:<br>
{% highlight assembly %}
operation <destination> <source>
{% endhighlight %}

Depending on what operation is being used, those source and destination values will be treated accordingly as the 
operation code demands. The destination and source values will either be a register, a memory address, or a value
The operations are usually intuitive mnemonics.<br>

For example the **MOV** operation will move a value from the source to the destination.
**SUB** will substract the source value from the destination value, **INC** will increment.

![](/assets/img/posts/binary-exploitation/8.png)<br>

The first instruction above will  move the value of the **rsp** to **rbp**. Then
the second instruction will substract 0x10 from the value which is written in the **rsp**.<br>

There are also flow control operations in the instruction set for the execution. **CMP** operation
compares two values, any operation starts with a **J** (jump) is being used to set the **EIP** into a 
different memory address value.

![](/assets/img/posts/binary-exploitation/4.png)<br>

## AT&T and Intel Syntax Differences

- AT&T prefixes the register with %, and immediates with $. Intel does not
do this.
- AT&T adds a prefix to the instruction to indicate operation width. For
example, MOVL (long), MOVB (byte), etc. Intel does not do this.
- AT&T puts the source operand before the destination. Intel reverses the
order.

Intel
{% highlight assembly %}
  mov ecx, AABBCCDDh
  mov ecx, [eax]
  mov ecx, eax
{% endhighlight %}
AT&T
{% highlight assembly %}
  movl $0xAABBCCDD, %ecx
  movl (%eax), %ecx
  movl %eax, %ecx
{% endhighlight %}


Since Intel representation is much more clean and understandable, I will be using Intel syntax from now on.
It is worth to note that syntax does not mean anything for the CPU, it is there for humans. 

# Processors
Processors have superfast memory units called caches and registers. Most of the instructions are actively
using those registers to read and write the data. Therefore, it is essential to understand how those
registers work in order to have a good understanding on how a CPU works.


## x86 Architecture
The x86 architecture has eight 32-bit general purpose registers (GPRs):
EAX, EBX, ECX, EDX, EDI, EBP and ESP. Some of them further divided into 8 and 16 bit registers. 
EIP is being used to store the instruction pointer.<br>
General purpose registers for x86 as the
following:
![](/assets/img/posts/binary-exploitation/5.png)<br>


| REGISTER               | Purpose                                                | 
|:-----------------------|:-------------------------------------------------------|
|ECX                     | Counter in loops                                      |
|ESI                     | Source in string/memory operations                     |
|EDI                     | Destination in string/memory operations                |
|EDP                     | Base frame pointer                                     |
|ESP                     | Stack pointer                                          |

The common data types are as follows:
- Bytes: 8 bits. Examples: AL, BL, CL
- Word: 6 bits. Examples: AX, BX, CX
- Double Word: 32 bits. Examples: EAX, EBX, ECX
- Quad Word: 64 bits. While x86 does not have 64-bit GPRs, it can combine
two registers, usually EDX:EAX, and treat them as 64-bit values in some 
scenarios. For example, the RDTSC instruction writes a 64-bit value to EDX:EAX.<br>

The 32-bit EFLAGS register is used to store the status of arithmetic operations
and other execution states for x86 as well as information 
about restrictions placed on the CPU operation at the current time.
For instance, if the an ADD
operation resulted in a zero, the ZF flag will be set to 1. The flags in EFLAGS are
primarily used to implement conditional branching.In addition to the GPRs, EIP, 
and EFLAGS, there are also registers that control
important low-level system mechanisms such as virtual memory, interrupts, and
debugging. For example, CR0 controls whether paging is on or off, CR2 contains
the linear address that caused a page fault, CR3 is the base address of a paging
data structure, and CR4 controls the hardware virtualization settings. DR0â€“DR7
are used to set memory breakpoints. Details are in the following sections.<br><br>
There are also model-specific registers (MSRs). As the name implies, these
registers may vary between different processors by Intel and AMD. Each MSR
is identified by name and a 32-bit number, and read/written to through the
RDMSR/WRMSR instructions.

## x64 Architecture
Since there are little to none 32 bit operating systems in real world, we will execute 
our practices on a 64 bit system. So we need to understand x64 architecture.<br>

x64 is an extension of x86, so most of the architecture properties are the same,
with minor differences such as register size and some instructions are unavailable. 
The following sections discuss the relevant differences.
![](/assets/img/posts/binary-exploitation/6.png)<br>
While RBP can still be used as the base frame pointer, it is rarely used for that
purpose in real-life compiler-generated code. Most x64 compilers simply treat
RBP as another GPR, and reference local variables relative to RSP.

## Data Movement
x64 supports a concept referred to as RIP-relative addressing, which allows  
instructions to reference data at a relative position to RIP. For example:
{% highlight assembly %}
01: 0000000000000000 48 8B 05 00 00+ mov rax, qword ptr cs:loc_A
02: ;                       originally written as "mov rax,[rip]"
03: 0000000000000007 loc_A:
{% endhighlight %}

Line 1 reads the address of loc_A (which is 0x7) and saves it in RAX. RIP-
relative addressing is primarily used to facilitate position-independent code.

## Function Invocation
Recall that some calling conventions require parameters to be passed on the
stack on x86. On x64, most calling conventions pass parameters through reg-
isters. For example, on Windows x64, there is only one calling convention and
the first four parameters are passed through RCX, RDX, R8, and R9; the remaining
are pushed on the stack from right to left. On Linux, the first six parameters are
passed on RDI, RSI, RDX, RCX, R8, and R9
# Debugging the Machine Code

We will use something called GDB (GNU Debugger). Debuggers are tools used by programmers to 
analyze compiled programs, step through them, examine the memory, CPU cache and registers.
A debugger can interfere the execution and change it along the way.
At the following picture, GDB is used to show the state of the processor registers right 
before the program starts.
![](/assets/img/posts/binary-exploitation/7.png)<br>

A breakpoint set on the main() function. Therefore, when we run the program, debugger will
pause the execution when the instruction pointer points the starting address of the main() function's 
first instruction. Then we examine the registers with their latest values before the call for the 
main() function took its place.<br>

The first four register, as mentioned above, are general purpose registers. And they are known 
as the **Accumulator**, **Counter**, **Data** and **Base** registers respectively.<br>

Following four registers are also GPRs. However, they are sometimes known as indexes and pointers.
These stand for **Stack Pointer**, **Base Pointer**, **Source Index**, **Destination Index** respectively.
**RSP** and **RBP** called pointers because they store 64-bit addresses, which essentially point to that location 
in the memory. These registers are fairly crucial to program execution and memory management. **RSI** and **RDI** 
are known as the **Source and Destination Indexes**, they too are technically pointers. They are commonly used 
to point to the source and destination when data needs to be read from or written to.<br>

There is one pointer register called **instruction pointer** which tracks the execution of the program. The
instruction pointer is stored in the **EIP** register, and it holds a 64-bit memory address.<br>

The remaining EFLAGS registers in the picture ( [PF ZF IF] ) actually consists of several bit flags that
are used for comparisons and memory segmentations. The actual memory is
split into several different segments, which will be discussed later, and these
registers keep track of that. For the most part, these registers can be ignored
since they rarely need to be accessed directly


